<?php

require_once __DIR__.'/ORMResult.php';
require_once __DIR__.'/ORMResultSet.php';

abstract class ORM
{
	/**
	 * Database Instance
	 * 
	 * @var Database
	 * @access protected
	 */
	protected static $db;
	
	/**
	 * Result class name
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $result_class 				= 'ORMResult';
	
	/**
	 * ResultSet class name
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $result_set_class 			= 'ORMResultSet';
	
	
	/**
	 * Primary key name
	 * Default is array('id')
	 * 
	 * @var array
	 * @access public
	 */
	public static $primary_keys 				= array('id');
	
	
	/**
	 * -----------------------------------
     * =========== Table Names ===========
	 * -----------------------------------
     */
	
	/**
	 * The name of the table active record is working with.
	 * Initialized in the constructor as the class name lower cased, undure_scored and pluralized
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $table_name;
	
	/**
	 * Suffix used for the internationalization table name
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $i18n_suffix 				= 'i18n';
	
	/**
	 * Internationalization table name, generated by the table name and the suffix
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $i18n_table_name;
	
	
	/**
	 * ------------------------------------
     * ======= Internationalization =======
	 * ------------------------------------
     */
	
	/**
	 * Is there an internationalization table, if null it will be set to the value in the Application Config
	 * 
	 * @var bool|null
	 * @access protected
	 */
	protected static $has_i18n;
	
	/**
	 * Are the records are mirrored or no, if null it will be set to the value in the Application Config
	 * 
	 * @var bool|null
	 * @access protected
	 */
	protected static $has_mirror;
    
	/**
	 * Current locale
	 * 
	 * @var string
	 * @access protected
	 * 
	 * @example 'ln_LN'
	 */
	protected static $i18n_locale;
	
	/**
	 * The code of the current locale
	 * 
	 * @var string
	 * @access protected
	 * 
	 * @example 'ln'
	 */
	protected static $i18n_locale_code;
	
	/**
	 * All the locales
	 * 
	 * @var array
	 * @access protected
	 * 
	 * @example array('ln' => 'ln_LN')
	 */
	protected static $i18n_locales 				= array();
	
	/**
	 * Name of the internationalization table foreign key linking to the main table
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $i18n_fk_field 			= 'i18n_foreign_key';
	
	/**
	 * Name of the internationalization table locale column
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $i18n_locale_field 		= 'i18n_locale';
	
	/**
	 * Primary key index responding to i18n foreign key field
	 * Default is 0
	 * 
	 * @var integer
	 */
	public static $primary_key_to_i18n_fk_field = 0;
	
	
	/**
	 * Appended to the selector or changeing the selector 
	 */
	public static $select_what 					= array();
	
//	public static $select_type					= 'only';
	public static $select_type					= 'append';
	
	
	/**
	 * ------------------------------------
     * ============== Cache ===============
	 * ------------------------------------
     */
	
	/**
	 * @var boolean
	 */
	public static $save_cache;
	
	/**
	 * @var integer/float munutes
	 */
	public static $cache_expire;
	
	
	/**
	 * ------------------------------------
     * ============= Methods =============
	 * ------------------------------------
     */
	
	/**
	 * 
	 * find_by_field_and_field
	 * find_all_by_field_and_field
	 * find_first_N
	 * 
	 * ($conditions, $joins)
	 * count_field
	 * count_distinct_field
	 * min_field
	 * max_field
	 * average_field
	 * average_distinct_field
	 * sum_field
	 * sum_distinct_field
	 * 
	 * ($conditions, $joins, $separator)
	 * group_field 
	 * group_distinct_field 
	 * 
	 * 
	 * increment_field
	 * decrement_field
	 * 
	 * 
	 */
	final public static function __callStatic($method, $params)
	{
		$find_functions			= array('find_all_by', 'find_by', 'find_first'); 
		$aggregate_functions	= array('count', 'min', 'max', 'average', 'sum', 'group');
		$increment_functions	= array('increment', 'decrement');
		
		if(preg_match('~('.implode('|', $find_functions).')_(\w+)~', $method, $matches))
		{
			return self::find_by($matches[1], $matches[2], $params);
		}
		else if(preg_match('~('.implode('|', $aggregate_functions).')(?:_(\w+))?~', $method, $matches))
		{
			return self::aggregate($matches[1], $matches[2], $params);
		}
		else if(preg_match('~('.implode('|', $increment_functions).')_(\w+)~', $method, $matches))
		{
			$n = (int)$params[1];
			$n || $n = 1;
			return self::$matches[1]($params[0], $matches[2], $n);
		}
	}
	
	final private static function aggregate($method, $field, $params)
	{
		if(substr($field, 0, strlen('distinct')) == 'distinct')
		{
			$distinct = 'DISTINCT ';
			$field = substr($field, strlen('distinct_'));
		}
		
		$method == 'average' && $method = 'avg';
		if($method == 'group')
		{
			$method = 'group_concat';
			$separator = ' SEPARATOR '.(isset($params[2]) ? '"'.trim(qstr($params[2]), '\'').'"' : '", "');
		}
		$field || $field = static::$primary_keys[0];
		
		return self::find_first($params[0], null, $params[1], $method.'('.$distinct.$field.$separator.') as r')->r;
	}
	
	final public static function increment($conditions, $field, $n = 1)
	{
		if(is_string($conditions) && empty($conditions)){ return false; }
		$table_name = static::table_name();
		
		is_string($conditions) || $conditions = self::do_primary_keys($conditions);
		return self::$db->query("UPDATE $table_name SET $field = $field + $n WHERE $conditions");
	}
	
	final public static function decrement($conditions, $field, $n = 1)
	{
		return self::increment($conditions, $field, $n * -1);
	}
	
	final private static function find_by($method, $fields, $params)
	{
		$fields = explode('_and_', $fields);
		$table_name = static::table_name();
		
		switch($method)
		{
			case 'find_all_by': case 'find_by':
			{
				$conditions = array();
				foreach($fields as $i => $f){ $conditions[] = $table_name.'.'.$f.'='.qstr($params[$i]); unset($params[$i]); }
				array_unshift($params, implode(' AND ', $conditions));
				
				$method == 'find_by' && $params['2'] = 1;
				$return = call_user_func_array(get_called_class().'::find_all', $params);
				$method == 'find_by' && $return = $return->results[0];
				
				return $return;
			}
			break;
			
			case 'find_first':
			{
//				params					conditions	order		joins		selector	selector_type 	limit');
				return self::find_first($params[0],	$params[1],	$params[2],	$params[3],	$params[4], 	$fields[5]);
			}
			break;
			
			default: break;
		}
	}
	
	final public static function find_all($conditions = null, $order = null, $limit = null, $joins = null, $selector = null, $selector_type = 'only')
	{
		if(substr($conditions, 0, 6) == 'SELECT'){ $sql = $conditions; }
		else
		{
			$table_name 		= static::table_name();
			$i18n_table_name 	= static::i18n_table_name();
			
			$primary_keys 		= static::$primary_keys;
			$i18n_fk_field 		= static::$i18n_fk_field;
			$i18n_locale_field 	= static::$i18n_locale_field;
			$i18n_locale 		= static::$i18n_locale;
			$pk_to_fk_index		= static::$primary_key_to_i18n_fk_field;
			
			$joins_what = $joins_tables = '';
			if(static::$has_i18n)
			{
				(!$selector || $selector_type == 'append') && $joins_what = ', '.$i18n_table_name.'.*';
				$joins_tables = " LEFT JOIN $i18n_table_name ON $table_name.{$primary_keys[$pk_to_fk_index]} = $i18n_table_name.$i18n_fk_field AND $i18n_table_name.$i18n_locale_field = '$i18n_locale' ";
			}
			
			
			if(is_array($joins) && isset($joins[0]) && is_array($joins[0]))
			{
				foreach($joins as $j)
				{
					if(is_string($j)){ $joins_tables .= $j.' '; continue; };
					 
					$j_model = $j['model'];
					isset($j['on']) || $j['on'] = " {$table_name}.".Inflector::singularize($j_model::table_name())."_{$j_model::$primary_keys[$j_model::$primary_key_to_i18n_fk_field]} ";
					
					$joins_paramas = $j_model::build_joins($j);
					
					(!$selector || $selector_type == 'append') && ($joins_paramas['what'] && $joins_what .= ','.$joins_paramas['what'].' ');
					$joins_tables .= $joins_paramas['tables'].' '; 
				}
			}
			
			$what = $table_name.'.*'; 
			if(static::$select_what)
			{
				$select_what = str_replace('$table', $table_name, implode(', ', static::$select_what));
				static::$select_type == 'append' ? $what .= ', '.$select_what : $what = $select_what;
			}
			$selector_type != 'append' && $selector_type = 'only';
			$selector && ($selector_type == 'append' ? $what .= ', '.$selector : $what = $selector);
			
			trim($conditions) 	&& $conditions 	= 'WHERE '		. $conditions;
			trim($order) 		&& $order 		= 'ORDER BY '	. $order;
			trim($limit) 		&& $limit 		= 'LIMIT '		. $limit;
			$sql  = "SELECT $what $joins_what FROM $table_name $joins_tables $conditions $order $limit";
		}
		
		static::before_find();
		
		(static::$save_cache && static::$cache_expire) && $query_md5 = md5($sql);
		if(static::$save_cache && static::$cache_expire && ( $result = self::cache_query_load($query_md5) )){  }
		else
		{
			$params = array
			(
				'table_name' => static::table_name(),
				'model_name' => get_called_class(),
			);
			
			$result = new static::$result_set_class(self::$db->fetch(self::$db->query($sql), static::$result_class, array($params)), $params);
			static::after_find($result);
			
			(static::$save_cache && static::$cache_expire) && self::cache_query_save($query_md5, $result);
		}
		
		return $result;
	}
	
	// array($id, $id2, $id3)
	final public static function find($primary_keys, $joins = null, $selector = null, $selector_type = 'only')
	{
		return static::find_all(static::do_primary_keys($primary_keys), null, 1, $joins, $selector, $selector_type)->results[0];
	}
	
	final public static function find_first($conditions = null, $order = null, $joins = null, $selector = null, $selector_type = 'only', $limit = 1)
	{
		is_array($conditions) && $conditions = static::do_primary_keys($conditions);
		$result = self::find_all($conditions, $order, $limit, $joins, $selector, $selector_type);
		$limit == 1 && $result = $result->results[0];
		
		return $result;
	}
	
	
	
	final public static function add(array $attributes)
	{
		$update_data = self::extract_data($attributes);
		if(!$update_data){ return false; }
		
		return self::$db->insert(static::table_name(), self::extract_data($attributes));
	}
	
	
	final public static function update($conditions, array $attributes, $order = null, $limit = null)
	{
		if(is_string($conditions) && empty($conditions)){ return false; }
		
		$update_data = self::extract_data($attributes);
		if(!$update_data){ return false; }
		
		is_string($conditions) || $conditions = self::do_primary_keys($conditions);
		
		trim($order) 		&& $order 		= ' ORDER BY '	. $order;
		trim($limit) 		&& $limit 		= ' LIMIT '		. $limit;
		return self::$db->update(static::table_name(), $update_data, $conditions, $order.$limit);
	}
	
	final public static function delete($conditions, $order = null, $limit = null)
	{
		if(is_string($conditions) && empty($conditions)){ return; }
		is_string($conditions) || $conditions = self::do_primary_keys($conditions);
		
		trim($order) 		&& $order 		= ' ORDER BY '	. $order;
		trim($limit) 		&& $limit 		= ' LIMIT '		. $limit;
		return self::$db->delete(static::table_name(), $conditions, $order.$limit);
	}
	
	final protected static function do_primary_keys($primary_keys)
	{
		$table 			= static::table_name();
		$primary_keys 	= (array)$primary_keys;
		$conditions 	= array();
		foreach(static::$primary_keys as $i => $pk){ $conditions[] = $table.'.'.$pk.'='.qstr($primary_keys[$i]); }
		
		return implode(' AND ', $conditions);
	}
	
	
	/**
	 * ------------------------------------
     * ============== Events ==============
	 * ------------------------------------
     */
	
	protected static function before_find(){}
	protected static function after_find($result){}
	
	
	/**
	 * 
	 * ------------------------------------
     * =========== Core Methods ===========
	 * ------------------------------------
     */
	
	final public static function __initialize()
	{
		self::$db = Registry::$db;
		
		self::$cache_expire = Database_Config::$cache_expire;
		self::$save_cache 	= Database_Config::$save_cache;
		
		self::$i18n_locale 		= Registry::$locales->current['i18n'];
		self::$i18n_locale_code = Registry::$locales->current['code'];
		
		self::$has_i18n 	= Application_Config::$has_i18n;
		self::$has_mirror 	= Application_Config::$has_mirror;
		
		foreach(Registry::$locales->info as $l){ self::$i18n_locales[$l['code']] = $l['i18n']; }
	}

	
	/**
	 * Returns model name 
	 */
	final public static function model_name()
	{
		return get_called_class();
	}
	
	/**
	 * Returns table name 
	 */
	final public static function table_name()
	{
		static $name;
		if($name){ return $name; }
		return $name ? $name : $name = static::$table_name ?: Inflector::tableize(get_called_class());
	}
	
	/**
	 * Returns u18n table name 
	 */
	final public static function i18n_table_name()
	{
		if(!static::$has_i18n){ return; }
		
		static $name;
		if($name){ return $name; }
		return $name ? $name : $name = static::table_name() .'_'. static::$i18n_suffix;
	}
	
	
	/**
	 * -----------------------------------
     * ============= Columns =============
	 * -----------------------------------
     */
	
	/**
	 * Columns info
	 * 
	 * @param integer type of columns to return. 
	 * 		COLUMNS_TYPE_ALL
	 * 		COLUMNS_TYPE_TABLE
	 * 		COLUMNS_TYPE_I18N
	 * 		COLUMNS_TYPE_ALL__ONLY_NAMES
	 * 		COLUMNS_TYPE_TABLE__ONLY_NAMES
	 * 		COLUMNS_TYPE_I18N__ONLY_NAMES
	 * @return array columns info
	 */
	const COLUMNS_TYPE_ALL 					= 0;
	const COLUMNS_TYPE_TABLE 				= 1;
	const COLUMNS_TYPE_I18N 				= 2;
	const COLUMNS_TYPE_ALL__ONLY_NAMES 		= 3;
	const COLUMNS_TYPE_TABLE__ONLY_NAMES 	= 4;
	const COLUMNS_TYPE_I18N__ONLY_NAMES 	= 5;
	final public static function columns($type = 0)
	{
		static $columns, $columns_info, $i18n_columns, $i18n_columns_info;
		
		$table = static::table_name();
		
		static::$save_cache && $timeless_folder = __FUNCTION__;
		static::$save_cache && $table_md5 = md5($table);
		if(!$columns[$table])
		{
			if(static::$save_cache && ($result = self::cache_query_load($table_md5, $timeless_folder)))
			{
				$columns_info[$table] = $result[0];
				$columns[$table] = $result[1];
			}
			else
			{
				$columns_info[$table] = self::$db->table_info($table)->columns;
				$columns[$table] = array_keys($columns_info[$table]);
				
				static::$save_cache && self::cache_query_save($table_md5, array($columns_info[$table], $columns[$table]), $timeless_folder);
			}
		}
		
		$table_i18n_md5 = md5($table.'_i18n');
		if(!$i18n_columns_info[$table] && static::$has_i18n && in_array($type, array(self::COLUMNS_TYPE_ALL, self::COLUMNS_TYPE_I18N, self::COLUMNS_TYPE_ALL__ONLY_NAMES, self::COLUMNS_TYPE_I18N__ONLY_NAMES)))
		{
			if(static::$save_cache && ($result = self::cache_query_load($table_i18n_md5, $timeless_folder)))
			{
				$i18n_columns_info[$table] = $result[0];
				$i18n_columns[$table] = $result[1];
			}
			else
			{
				$i18n_columns_info[$table] = self::$db->table_info(static::i18n_table_name())->columns;
				$i18n_columns[$table] = array_keys($i18n_columns_info[$table]);
				
				static::$save_cache && self::cache_query_save($table_i18n_md5, array($i18n_columns_info[$table], $i18n_columns[$table]), $timeless_folder);
			}
		}

		$columns[$table] 			|| $columns[$table] 			= array();
		$columns_info[$table] 		|| $columns_info[$table] 		= array();
		$i18n_columns[$table] 		|| $i18n_columns[$table] 		= array();
		$i18n_columns_info[$table] 	|| $i18n_columns_info[$table] 	= array();
		
		switch($type)
		{
			case self::COLUMNS_TYPE_TABLE				: return $columns_info[$table]	;												break;
			case self::COLUMNS_TYPE_I18N				: return $i18n_columns_info[$table];											break;
			
			case self::COLUMNS_TYPE_TABLE__ONLY_NAMES	: return $columns[$table];														break;
			case self::COLUMNS_TYPE_I18N__ONLY_NAMES	: return $i18n_columns[$table];													break;
			
			case self::COLUMNS_TYPE_ALL__ONLY_NAMES		: return array_merge($columns[$table], $i18n_columns[$table]);					break;

			case self::COLUMNS_TYPE_ALL:
			default:									  return array_merge($columns_info[$table], $i18n_columns_info[$table]);		break;
		}
	}
	
	const STATUS_TYPE_ALL 	= 0;
	const STATUS_TYPE_TABLE = 1;
	const STATUS_TYPE_I18N 	= 2;
	final public static function status($type = 0)
	{
		static $status, $i18n_status;
		
		$table = static::table_name();
		
		static::$save_cache && $timeless_folder = __FUNCTION__;
		static::$save_cache && $table_md5 = md5($table);
		if(!$status[$table])
		{
			if(static::$save_cache && ($result = self::cache_query_load($table_md5, $timeless_folder)))
			{
				$status[$table] = $result;
			}
			else
			{
				$status[$table] = self::$db->table_info(static::table_name())->status;
				
				static::$save_cache && self::cache_query_save($table_md5, $status[$table], $timeless_folder);
			}
		}
		
		$table_i18n_md5 = md5($table.'_i18n');
		if(!$i18n_status[$table] && static::$has_i18n && in_array($type, array(self::COLUMNS_TYPE_ALL, self::COLUMNS_TYPE_I18N, self::COLUMNS_TYPE_ALL__ONLY_NAMES, self::COLUMNS_TYPE_I18N__ONLY_NAMES)))
		{
			if(static::$save_cache && ($result = self::cache_query_load($table_i18n_md5, $timeless_folder)))
			{
				$i18n_status[$table] = $result;
			}
			else
			{
				$i18n_status[$table] = self::$db->table_info(static::i18n_table_name())->status;
				
				static::$save_cache && self::cache_query_save($table_i18n_md5, $i18n_status[$table], $timeless_folder);
			}
		}
		
		
		$status[$table] 		|| $status[$table] 		= array();
		$i18n_status[$table] 	|| $i18n_status[$table] = array();
		
		switch($type)
		{
			case self::STATUS_TYPE_TABLE	: return $status[$table];										break;
			case self::STATUS_TYPE_I18N		: return $i18n_status[$table];									break;

			case self::STATUS_TYPE_ALL:
			default:						  return array_merge($status[$table], $i18n_status[$table]);	break;
		}
	}
	
	const INDICES_TYPE_ALL 		= 0;
	const INDICES_TYPE_TABLE 	= 1;
	const INDICES_TYPE_I18N 	= 2;
final public static function indices($type = 0)
	{
		static $indices, $i18n_indices;
		
		$table = static::table_name();
		
		static::$save_cache && $timeless_folder = __FUNCTION__;
		static::$save_cache && $table_md5 = md5($table);
		if(!$indices[$table])
		{
			if(static::$save_cache && ($result = self::cache_query_load($table_md5, $timeless_folder)))
			{
				$indices[$table] = $result;
			}
			else
			{
				$indices[$table] = self::$db->table_info(static::table_name())->indices;
				
				static::$save_cache && self::cache_query_save($table_md5, $indices[$table], $timeless_folder);
			}
		}
		
		$table_i18n_md5 = md5($table.'_i18n');
		if(!$i18n_indices[$table] && static::$has_i18n && in_array($type, array(self::COLUMNS_TYPE_ALL, self::COLUMNS_TYPE_I18N, self::COLUMNS_TYPE_ALL__ONLY_NAMES, self::COLUMNS_TYPE_I18N__ONLY_NAMES)))
		{
			if(static::$save_cache && ($result = self::cache_query_load($table_i18n_md5, $timeless_folder)))
			{
				$i18n_indices[$table] = $result;
			}
			else
			{
				$i18n_indices[$table] = self::$db->table_info(static::i18n_table_name())->indices;
				
				static::$save_cache && self::cache_query_save($table_i18n_md5, $i18n_indices[$table], $timeless_folder);
			}
		}
		
		
		$indices[$table] 		|| $indices[$table] 		= array();
		$i18n_indices[$table] 	|| $i18n_indices[$table] 	= array();
		switch($type)
		{
			case self::INDICES_TYPE_TABLE	: return $indices[$table];								break;
			case self::INDICES_TYPE_I18N	: return $i18n_indices[$table];							break;

			case self::INDICES_TYPE_ALL:
			default:						  return array_merge(array_values($indices[$table]), array_values($i18n_indices[$table]));	break;
		}
	}
	
	final protected static function extract_data($attributes)
	{
		foreach(static::columns(self::COLUMNS_TYPE_ALL__ONLY_NAMES) as $col)
		{
			isset($attributes[$col]) && $_attributes[$col] = $attributes[$col];
		}
		return $_attributes;
	}
	
	final public static function build_joins($params)
	{
		$table = static::table_name();
		isset($params['prefix']) && $table = $params['prefix'].'_'.$table;
		$alias = isset($params['table_alias']) ? $params['table_alias'] : $table;
		$table_singular = Inflector::singularize($alias);
		
		
		$what = array();
		isset($params['what']) || $params['what'] = array();
		
		foreach(static::columns(self::COLUMNS_TYPE_TABLE__ONLY_NAMES) as $c)
		{ 
			$what[] = "$alias.{$c} AS {$table_singular}_{$c}"; 
		}
		
		$force_index = isset($params['force_index']) ? "FORCE INDEX({$params['force_index']})" : '';
		
		$primary_keys = static::$primary_keys;
		
		$primary_key = isset($params['primary_key']) ? $params['primary_key'] : 0;
		is_int($primary_key) && $primary_key = $primary_keys[$primary_key];
		
		$params['on'] = trim($params['on']);
		if(strstr($params['on'], ' ') === false && strstr($params['on'], '=') === false){ $params['on'] = " {$params['on']} = {$alias}.{$primary_key} "; }
		
		$tables = "{$params['type']} JOIN {$table} as $alias $force_index ON {$params['on']} ";
		
		
		if(static::$has_i18n)
		{
			$i18n_fk_field 		= static::$i18n_fk_field;
			$i18n_locale_field 	= static::$i18n_locale_field;
			$i18n_suffix 		= static::$i18n_suffix;
			$i18n_locale		= static::$i18n_locale;
			
			foreach (static::columns(self::COLUMNS_TYPE_I18N__ONLY_NAMES) as $c)
			{
				if(!in_array($c, array($i18n_fk_field, $i18n_locale_field))){ $what[] = "{$alias}_{$i18n_suffix}.{$c} AS {$table_singular}_{$c}"; }
			}
			
			
			$i18n_table = static::i18n_table_name();
			$tables .= "LEFT JOIN {$i18n_table} as {$alias}_{$i18n_suffix} ON {$alias}.{$primary_key} = {$alias}_{$i18n_suffix}.{$i18n_fk_field} AND {$alias}_{$i18n_suffix}.{$i18n_locale_field} = '{$i18n_locale}'";
		}
		$what = array_merge($what, $params['what']);
		
		return array('what' => implode(', ', $what), 'tables' => $tables, 'no_model' => isset($params['table']));
	}
	
	/**
	 * ------------------------------------
     * ============== Cache ===============
	 * ------------------------------------
     */
	
	/**
	 * Check if cache file exists and if it is not too old will load it
	 */
	final private static function cache_query_load($query_md5, $timeless = null)
	{
		$path = self::cache_query_getPath($query_md5, $timeless);
		
		$is_valid = file_exists($path) && ($timeless ? true : time()-filemtime($path) <= static::$cache_expire * 60);
		return ($is_valid || file_exists($path) && !self::$db->is_connected()) ? unserialize(file_get_contents($path)) : false;
	}
	
	final private static function cache_query_save($query_md5, $result, $timeless = null)
	{
		$path = self::cache_query_getPath($query_md5, $timeless);
		
		$folder = substr($path, 0, strrpos($path, '/'));
		file_exists($folder) || mkdir($folder, 0777, true);
		
		file_put_contents($path, serialize($result), 9);
	}
	
	final private static function cache_query_getPath($md5, $timeless = null)
	{
		static $paths;
		
		if($paths[$md5]){ return $paths[$md5]; }
		else
		{
			$md5{2} = '/';
			$timeless && $timeless = '_'.$timeless;
			return $paths[$md5] = SystemConfig::$tempPath . Database_Config::$cache_folder . $timeless . '/' . $md5;
		}
		
	}
}
ORM::__initialize();

?>
