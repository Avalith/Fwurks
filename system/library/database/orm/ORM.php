<?php

require_once __DIR__.'/ORMQuery.php';
require_once __DIR__.'/ORMQueryQueue.php';
require_once __DIR__.'/ORMResult.php';
require_once __DIR__.'/ORMResultSet.php';
require_once __DIR__.'/ORMColumn.php';
require_once __DIR__.'/ORMRelation.php';

abstract class ORM
{
	/**
	 * Primary key name
	 * Default is array('id')
	 * 
	 * @var array
	 * @access public
	 */
	protected static $primary_keys 					= array('id');
		
	/**
	 * Selector
	 * 
	 * @var string
	 * @access public
	 */
	protected static $selector						= null;
	
	/**
	 * Result class name
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $result_class 					= 'ORMResult';
	
	/**
	 * ResultSet class name
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $result_set_class 				= 'ORMResultSet';
	
	
	/**
	 * -----------------------------------
     * =========== Table Names ===========
	 * -----------------------------------
     */
	
	/**
	 * The name of the table active record is working with.
	 * Initialized in the constructor as the class name lower cased, undure_scored and pluralized
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $table_name					= null;
	
	protected static $table_engine					= SqlTable::ENGINE_INNODB;
	
	
	/**
	 * Suffix used for the internationalization table name
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $i18n_suffix 					= 'i18n';
	
	/**
	 * Internationalization table name, generated by the table name and the suffix
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $i18n_table_name				= null;
	
	
	/**
	 * ------------------------------------
     * ======= Internationalization =======
	 * ------------------------------------
     */
	
	/**
	 * Is there an internationalization table, if null it will be set to the value in the Application Config
	 * 
	 * @var Boolean
	 * @access protected
	 */
	protected static $has_i18n						= false;
	
	/**
	 * Are the records are mirrored or no, if null it will be set to the value in the Application Config
	 * 
	 * @var Boolean
	 * @access protected
	 */
	protected static $has_mirror					= false;
    
	/**
	 * Current locale
	 * 
	 * @var string
	 * @access protected
	 * 
	 * @example 'ln_LN'
	 */
	protected static $i18n_locale					= null;
	
	/**
	 * All the locales
	 * 
	 * @var array
	 * @access protected
	 * 
	 * @example array('ln' => 'ln_LN')
	 */
	protected static $i18n_locales 					= array();
	
	/**
	 * Name of the internationalization table foreign key linking to the main table
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $i18n_fk_field 				= 'i18n_foreign_key';
	
	/**
	 * Name of the internationalization table locale column
	 * 
	 * @var string
	 * @access protected
	 */
	protected static $i18n_locale_field 			= 'i18n_locale';
	
	/**
	 * Primary key index responding to i18n foreign key field
	 * Default is 0
	 * 
	 * @var integer
	 */
	protected static $primary_key_to_i18n_fk_field 	= 0;
	
	
	/**
	 * ------------------------------------
     * ============= Methods ==============
	 * ------------------------------------
     */
	
	/**
	 * @return ORMQuery
	 */
	final public static function query($result_set = null, $result_class = null, array $result_params = array())
	{
		$result_class 	|| $result_class 	= static::$result_class;
		$result_set 	|| $result_set 		= static::$result_set_class;
		$result_params = array_merge(static::result_params(), $result_params);
		
		return new ORMQuery(static::table_name(), $result_class, $result_set, $result_params);
	}
	
	
	final public static function join()
	{
		return SqlJoin(static::table_name());
	}
	
	
	final public static function join_i18n($load_all_locales = false)
	{
		if(static::$has_i18n)
		{
			$table_name 	= static::table_name();
			$i18n_table_name 	= static::i18n_table_name();
			
			$primary_keys 		= static::$primary_keys;
			$i18n_fk_field 		= static::$i18n_fk_field;
			$i18n_locale_field 	= static::$i18n_locale_field;
			$i18n_locale 		= static::$i18n_locale;
			$i18n_locales 		= static::$i18n_locales;
			$pk_to_fk_index		= static::$primary_key_to_i18n_fk_field;
			
			$on_locale = $load_all_locales ? '' : " AND {$i18n_table_name}.{$i18n_locale_field} = '{$i18n_locale->i18n}'";
			return SqlJoin($i18n_table_name)->left()->on("{$table_name}.{$primary_keys[$pk_to_fk_index]} = {$i18n_table_name}.{$i18n_fk_field}{$on_locale}");
		}
		
		return null;
	}
	
	
	
	
	/**
	 * @param String/Array $conditions
	 * @param String $order
	 * @param String $limit
	 * @param Boolean $join_i18n
	 * @return ORMQuery
	 */
	final public static function find($conditions = null, $order = null, $limit = null, $join_i18n = true, $load_all_locales = false)
	{
		$table_name = static::table_name();
		$query = self::query();
		
		$selector = static::$selector ?: "$table_name.*";
		$query->select($selector)->where((array)$conditions)->order($order)->limit($limit);
		
		
		if(static::$has_i18n && $join_i18n)
		{
			
			$i18n_table_name 	= static::i18n_table_name();
			
			$query->addSelect($i18n_table_name.'.*');
			$query->join(static::join_i18n($load_all_locales));
		}
		
		return $query;	
	}
	
	
	/**
	 * find_by_field_and_field	($value, $value, $order, $limit)
	 * 
	 * count_field 				($conditions)
	 * count_distinct_field		($conditions)
	 * min_field				($conditions)
	 * max_field				($conditions)
	 * average_field			($conditions)
	 * average_distinct_field	($conditions)
	 * sum_field				($conditions)
	 * sum_distinct_field		($conditions)
	 * group_field				($conditions)
	 * group_distinct_field		($conditions)
	 * 
	 * increment_field()
	 * decrement_field()
	 */
	final public static function __callStatic($method, $params)
	{
		$find_functions			= 'find_by'; 
		$aggregate_functions	= 'count|min|max|average|sum|group';
		$increment_functions	= 'increment|decrement';
		
		if(preg_match("~($find_functions)_(\w+)~", $method, $matches))
		{
			return self::find_by($matches[1], $matches[2], $params);
		}
		else if(preg_match("~($aggregate_functions)(?:_(\w+))?~", $method, $matches))
		{
			isset($matches[2]) || $matches[2] = null;
			return self::aggregate($matches[1], $matches[2], $params);
		}
		else if(preg_match("~($increment_functions)_(\w+)~", $method, $matches))
		{
			$n = isset($params[0]) ? (int)$params[0] : 1;
			return self::$matches[1]($matches[2], $n);
		}
	}
	
	
	final private static function aggregate($method, $field, $params)
	{
		$conditions = isset($params[0]) ? $params[0] : null;
		$join_i18n 	= isset($params[1]) ? $params[1] : false;
		$query 		= static::find($conditions, null, null, $join_i18n);
		
		if(substr($field, 0, /*strlen('distinct')*/8) == 'distinct')
		{
			$field = substr($field, strlen('distinct_'));
			$query->distinct();
		}
		
		$method == 'average' && $method = 'avg';
		$separator = null;
		if($method == 'group')
		{
			$method = 'group_concat';
			$separator = ' SEPARATOR ","';
		}
		$field || $field = static::$primary_keys[0];
		
		$query->select(strtoupper($method).'('.$field.$separator.') as '.$method)->where(isset($params[0]) ? $params[0] : null);
		
		return $query;
	}
	
	
	final public static function increment($field, $n = 1)
	{
		return static::query()->update(array($field.'?sql' => $field.'+'.(int)$n));
	}
	
	
	final public static function decrement($field, $n = 1)
	{
		return static::query()->update(array($field.'?sql' => $field.'-'.(int)$n));
	}
	
	
	final private static function find_by($method, $fields, $params)
	{
		$table_name = static::table_name();
		$columns 	= static::columns(self::COLUMNS_TYPE_TABLE);
		
		if(static::$has_i18n)
		{
			$table_name_i18n = static::i18n_table_name();
			$columns_i18n = static::columns(self::COLUMNS_TYPE_I18N);
		}
		
		$fields = explode('_and_', $fields);
		$values = array();
		foreach($fields as $i => $f)
		{
			if(isset($columns->$f))
			{
				$conditions[] = $table_name.'.'.$f.' = ?'.$columns->$f->getEscapeChar();
			}
			else if(static::$has_i18n && isset($columns_i18n->$f))
			{
				$conditions[] = $table_name_i18n.'.'.$f.' = ?'.$columns_i18n->$f->getEscapeChar();
			}
			else
			{
				$conditions[] = $f.' = ?';
			}
			
			$values[] = array_shift($params);
		}
		$conditions = array_merge((array)implode(' AND ', $conditions), $values);
		
		$order = isset($params[0]) ? $params[0] : null;
		$limit = isset($params[1]) ? $params[1] : null;
		
		return static::find($conditions, $order, $limit);
	}
	
	
	public static function get_all($selector = '*', $conditions = null, $order = null, $limit = null, $join_i18n = true)
	{
		return static::find($conditions, $order, $limit, $join_i18n)->select($selector)->result();
	}
	
	
	/**
	 * @param Array $field_values
	 * @return ORMQuery
	 */
	final public static function insert(array $field_values, $conditions = null)
	{
		return static::query()->insert($field_values);
	}
	
	
	/**
	 * @param Array $field_values
	 * @return ORMQuery
	 */
	final public static function replace(array $field_values, $conditions = null)
	{
		return static::query()->replace($field_values);
	}
	
	
	/**
	 * @param String/Array $field_values
	 * @param Array $conditions
	 * @param String $order
	 * @param Integer $limit
	 * @return ORMQuery
	 */
	final public static function update(array $field_values, $conditions = null, $order = null, $limit = null)
	{
		return static::query()->update($field_values)->where((array)$conditions)->order($order)->limit($limit);
	}
	
	
	/**
	 * @param String/Array $conditions
	 * @param String $order
	 * @param Integer $limit
	 * @return ORMQuery
	 */
	final public static function delete($conditions, $order = null, $limit = null)
	{
		if(!$conditions){ return false; }
		
		$query = static::query()->delete()->order($order)->limit($limit)->where((array)$conditions);
		
		return $query;
	}
	
	
	
	/**
	 * ------------------------------------
     * =========== Core Methods ===========
	 * ------------------------------------
     */
	
	final public static function __initialize()
	{
		self::$i18n_locale 		= Registry::$locales->current;
		self::$i18n_locales		= Registry::$locales->info;
	}

	
	/**
	 * Returns model name 
	 */
	final public static function model_name()
	{
		return get_called_class();
	}
	

	/**
	 * Returns table name 
	 */
	final public static function table_name()
	{
		static $name = null;
		return $name ?: ( $name = static::$table_name ?: Inflector::tableize(get_called_class()) );
	}
	
	
	/**
	 * Returns table engine 
	 */
	final public static function table_engine()
	{
		return static::$table_engine;
	}
	
	
	/**
	 * Returns i18n table name 
	 */
	final public static function i18n_table_name()
	{
		if(!static::$has_i18n){ return; }
		
		static $name = null;
		return $name ?: $name = static::table_name() .'_'. static::$i18n_suffix;
	}
	
	
	final public static function primary_keys($key = null)
	{
		return $key === null ? static::$primary_keys : static::$primary_keys[$key];
	}
	
	
	
	
	public static function result_params()
	{
		return array
		(
			'table_name' 	=> static::table_name(),
			'model_name' 	=> static::model_name(),
			'relations'		=> static::relations(),
		);
	}
	
	public static function new_result_set($results = array())
	{
		return new static::$result_set_class($results, static::result_params());
	}
	
	public static function new_result()
	{
		return new static::$result_class(static::result_params());
	}
	
	
	/**
	 * -----------------------------------
     * ============= Columns =============
	 * -----------------------------------
     */
	
	const COLUMNS_TYPE_ALL 					= 10;
	const COLUMNS_TYPE_TABLE 				= 11;
	const COLUMNS_TYPE_I18N 				= 12;
	const COLUMNS_TYPE_ALL__ONLY_NAMES 		= 20;
	const COLUMNS_TYPE_TABLE__ONLY_NAMES 	= 21;
	const COLUMNS_TYPE_I18N__ONLY_NAMES 	= 22;
	
	/**
	 * Columns info
	 * 
	 * @param integer type of columns to return. 
	 * 		COLUMNS_TYPE_ALL
	 * 		COLUMNS_TYPE_TABLE
	 * 		COLUMNS_TYPE_I18N
	 * 		COLUMNS_TYPE_ALL__ONLY_NAMES
	 * 		COLUMNS_TYPE_TABLE__ONLY_NAMES
	 * 		COLUMNS_TYPE_I18N__ONLY_NAMES
	 * @return array columns info
	 */
	final public static function columns($type = self::COLUMNS_TYPE_ALL)
	{
		static $columns = array(), $columns_info = array(), $i18n_columns = array(), $i18n_columns_info = array(), $all_columns = array(), $all_columns_info = array();
		
		$table = static::table_name();
		
		isset($columns[$table]) 			|| $columns[$table] 			= array();
		isset($columns_info[$table]) 		|| $columns_info[$table] 		= array();
		isset($i18n_columns[$table]) 		|| $i18n_columns[$table] 		= array();
		isset($i18n_columns_info[$table]) 	|| $i18n_columns_info[$table] 	= array();
		
		if(!$columns[$table])
		{
			$columns[$table] 		= array();
			$columns_info[$table] 	= new StdClass();

			
			$cols = array();
			foreach(static::__columnDefinitions() as $c)
			{
				$cname = $c->name();
				$cols[$cname] = $c;
				
				if($c->is_file())
				{
					$opts = $c->get_file_options();
					
					$opts->save_filename && $cols[$cname.'_filename'] = ORMColumn($cname)->FileName();
					$opts->save_filetype && $cols[$cname.'_filetype'] = ORMColumn($cname)->FileType();
					$opts->save_filesize && $cols[$cname.'_filesize'] = ORMColumn($cname)->FileSize();
					
					foreach($opts->crops as $size)
					{
						$cols[$cname.'_c'.$size] = ORMColumn($cname)->FileImage('c'.$size);
					}
					foreach($opts->resizes as $size)
					{
						$cols[$cname.'_r'.$size] = ORMColumn($cname)->FileImage('r'.$size);
					}
				}
			}
			
			foreach($cols as $c)
			{
				$columns_info[$table]->{$c->name()} = $c;
				$columns[$table][] = $c->name();
				$all_columns_info[$table]->{$c->name()} = $c;
				$all_columns[$table][] = $c->name();
			}
			unset($cols);
		}
		
		// $i%10 != 1 means self::COLUMNS_TYPE_ALL or self::COLUMNS_TYPE_I18N or self::COLUMNS_TYPE_ALL__ONLY_NAMES or self::COLUMNS_TYPE_I18N__ONLY_NAMES
		if(!$i18n_columns[$table] && static::$has_i18n && $type%10 != 1)
		{
			$id = static::columns(self::COLUMNS_TYPE_TABLE)->{static::primary_keys(0)};
			
			$i18n_columns[$table] 		= array();
			$i18n_columns_info[$table] 	= new StdClass();
			
			$fk_field = ORMColumn(static::$i18n_fk_field)->{$id->type()}($id->get_length(), $id->get_decimals())->primary();
			$id->is_unsigned() && $fk_field->unsigned();
			
			$lc_field = ORMColumn(static::$i18n_locale_field)->enum(Registry::$locales->all)->primary();
			
			$i18n_columns_info[$table]->{$fk_field->name()} = $fk_field;
			$i18n_columns[$table][] = $fk_field->name();
			$all_columns_info[$table]->{$fk_field->name()} = $fk_field;
			$all_columns[$table][] = $fk_field->name();
			
			$i18n_columns_info[$table]->{$lc_field->name()} = $lc_field;
			$i18n_columns[$table][] = $lc_field->name();
			$all_columns_info[$table]->{$lc_field->name()} = $lc_field;
			$all_columns[$table][] = $lc_field->name();
			
			foreach(static::__i18n_columnDefinitions() as $c)
			{
				$i18n_columns_info[$table]->{$c->name()} = $c;
				$i18n_columns[$table][] = $c->name();
				$all_columns_info[$table]->{$c->name()} = $c;
				$all_columns[$table][] = $c->name();
			}
		}
		
		switch($type)
		{
			case self::COLUMNS_TYPE_TABLE				: return $columns_info[$table]	;		break;
			case self::COLUMNS_TYPE_I18N				: return $i18n_columns_info[$table];	break;
			
			case self::COLUMNS_TYPE_TABLE__ONLY_NAMES	: return $columns[$table];				break;
			case self::COLUMNS_TYPE_I18N__ONLY_NAMES	: return $i18n_columns[$table];			break;
			
			case self::COLUMNS_TYPE_ALL__ONLY_NAMES		: return $all_columns[$table];			break;
			case self::COLUMNS_TYPE_ALL: default		: return $all_columns_info[$table];		break;
		}
	}
	
	abstract protected static function __columnDefinitions();
	
	
	
	/**
	 * -----------------------------------
     * ============ Relations ============
	 * -----------------------------------
     */
	
	/**
	 * 
	 * @return Array:
	 */
	protected function __relations()
	{
		return array();
	} 
	
	public static function relations()
	{
		static $relations = array();
		
		$table = static::table_name();
		if(!isset($relations[$table]))
		{
			$relations[$table] = new StdClass();
			foreach(static::__relations() as $r)
			{
				$relations[$table]->{$r->name()} = $r->model(static::model_name());
			}
		}
		
		return $relations[$table];
	}
	
}

ORM::__initialize();

?>
